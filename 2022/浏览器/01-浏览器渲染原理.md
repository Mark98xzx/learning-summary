
## 浏览器渲染原理

### 一 进程与线程

- 进程是操作系统资源分配的基本单位, 进程中包含线程
- 线程是由进程所管理的; 为了提升浏览器的稳定性和安全性, 浏览器采用了多进程模型

#### 浏览器中的五个进程

![浏览器多进程模型](../imgs/16-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png)

- **浏览器进程**: 负责界面显示, 用户交互, 子进程管理, 提供存储等
- **渲染进程**: 每个页卡都有单独的渲染进程, 核心用于渲染页面
- **网络进程**: 主要处理网络资源加载(HTML CSS JS 等)
- **GPU进程**: 3d 绘制, 提高性能
- **插件进程**: chrome中安装的一些插件

### 二 从输入URL到浏览器显示页面发生了什么?

> 用户输入的是关键字还是URL? 如果是关键字则用使用默认搜索引擎生成URL

#### 1. 浏览器进程是相互调用

- 在浏览器进程中输入 url 地址开始导航, 并准备渲染进程
- 在网络进程中发送请求, 加载资源, 将响应后的结果交给渲染进程处理
- 解析页面, 加载页面所需资源

#### 2. URL 请求过程

- 网络七层模型 (物理层 数) 网(ip)  传(tcp 安全可靠,可分段传输; udp 丢包)  (会 表 应) http
- 先去查找缓存, 检测缓存是否过去; 直接返回缓存中内容
- 看域名是否被解析过, DNS协议, 将域名解析成ip地址(DNS 基于 UDP) ip+端口号 host
- 请求是 HTTPS SSL协商
- ip地址来进行寻址, 排队等待, 最多能发送 6个http请求
- tcp 创建链接, 用于传输(三次握手)
- 利用tcp传输数据 (拆分成数据包, 有序, 可靠) 服务器会按照顺序来接收
- http 请求(请求行, 请求头, 请求体)
- 默认不会端开 keep-alive 为了下次传输数据时,可以复用上次的创建的链接
- 服务器收到数据后(响应行, 响应头, 响应体)
- 服务器返回 301 302 会进行重定向操作
- 服务器 304 去查询浏览器缓存进行返回

> 浏览器接受资源后怎么处理

#### 3. HTTP 发展历程

http 0.9 负责传输html, 最早的时候没有请求头和响应头
http 1.0 提供了 header; 根据header的不同来处理不同的资源
http 1.1 默认开启了 keep-alive 链接复用; 管线化; 服务器处理多个请求(队头阻塞问题)
http 2.0 用同一个 tcp 链接来发送数据, 一个域名一个tcp(多路复用); 头部压缩; 服务器可以推送数据给客户端
http 3.0 解决了tcp的队头阻塞问题; 采用QUIC 协议,采用了udp

#### 4. 渲染流程

![渲染流程](../imgs/17-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png)

- 1. 浏览器无法直接使用 HTML, 需要将 HTML 转化成 DOM 树(document)
- 2. 浏览器无法解析纯文本的css 样式,需要对 css 进行解析, 解析成 styleSheets, CSSOM (document.styleSeets)
- 3. 计算出DOM树中每个节点的具体样式(Attachment)
- 4. 创建渲染(布局)树, 将DOM树中可见节点, 添加到布局树中; 并计算节点渲染到页面的坐标位置(layout)
- 5. 通过布局树,进行分层(根据定位属性, 透明属性, transform属性, clip属性等) 生成图层树
- 6. 将不同图层进行绘制, 转交给合成线程处理; 最终生成页面, 并显示到浏览器上(Painting, Display)

#### dom生成

- 在解析前会执行预解析操作, 会预先加载 js, css 等文件
- 字节流 -> 分词器 -> Tokens -> 根据token生成节点 -> 插入到DOM树中
- 遇到 js: 在解析过程中遇到 script 标签, HTMLParser 会停止解析, (下载)执行对应脚本
- 在 js 执行前, 需要等待当前脚本之上的所有 css 加载解析完毕 (js 是依赖 css 的加载)

![18-生成dom树](../imgs//18-%E7%94%9F%E6%88%90dom%E6%A0%91.png)